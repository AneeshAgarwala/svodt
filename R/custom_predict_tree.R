#' @title Predict with a Decision Tree
#' @description
#' Predicts class labels or class probabilities for new data using a decision tree
#' generated by \code{generate_tree}. Handles internal nodes, leaf nodes, and
#' both numeric and factor splits. Supports batch predictions for data frames.
#'
#' @param node A decision tree object returned by \code{generate_tree}.
#' @param input A named list representing a single observation or a data frame of observations.
#' @param return_probs Logical; if \code{TRUE}, returns class probabilities instead of predicted labels.
#'
#' @return If \code{return_probs = FALSE}, returns a character vector of predicted class labels.
#' If \code{return_probs = TRUE}, returns a numeric matrix or named vector of class probabilities.
#'
#' @details
#' - Supports numeric and factor features in internal nodes.
#' - For numeric features, splits are \code{<=} for left and \code{>} for right.
#' - For factor features, matches the split level for left; all other levels go right.
#' - Batch predictions for data frames are automatically handled row-wise.
#' - If a required feature is missing in the input, a warning is issued and \code{NA} is returned.
#' - Probabilities are returned as a named vector for a single observation or a matrix for multiple rows.
#'
#' @examples
#' data(wdbc)
#' features <- wdbc[, 2:31]
#' target <- wdbc$diagnosis
#' tree <- generate_tree(target, features, max_depth = 3)
#'
#' # Predict single observation
#' predict_tree(tree, as.list(features[1, ]))
#'
#' # Predict multiple observations
#' predict_tree(tree, features[1:5, ], return_probs = TRUE)
#'
#' @export
predict_tree <- function(node, input, return_probs = FALSE) {
  # Batch prediction for data.frame input
  if (is.data.frame(input)) {
    preds <- lapply(seq_len(nrow(input)), function(i) {
      predict_tree(node, as.list(input[i, , drop = FALSE]), return_probs = return_probs)
    })

    if (return_probs) {
      preds_matrix <- do.call(rbind, preds)
      rownames(preds_matrix) <- NULL
      return(preds_matrix)
    } else {
      return(unlist(preds))
    }
  }

  # Leaf node
  if (is.null(node$split_feature)) {
    if (return_probs) {
      return(node$probs)
    } else {
      return(node$prediction)
    }
  }

  # Internal node: route by split
  feature_value <- input[[node$split_feature]]
  if (is.null(feature_value)) {
    warning(paste("Missing feature:", node$split_feature, "- returning NA"))
    if (return_probs) {
      return(rep(NA_real_, length(node$probs)))
    } else {
      return(NA)
    }
  }

  if (is.numeric(feature_value) && is.numeric(node$split_value)) {
    if (feature_value <= node$split_value) {
      return(predict_tree(node$left, input, return_probs))
    } else {
      return(predict_tree(node$right, input, return_probs))
    }
  } else {
    if (feature_value == node$split_value) {
      return(predict_tree(node$left, input, return_probs))
    } else {
      return(predict_tree(node$right, input, return_probs))
    }
  }
}
